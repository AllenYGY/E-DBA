"""change policy file_path to file_content

Revision ID: 7d448d75a6e1
Revises: 09106b6eef5a
Create Date: 2025-05-16 13:54:33.888710

"""
from typing import Sequence, Union
import os

from alembic import op
import sqlalchemy as sa
from sqlalchemy import text
from sqlalchemy.dialects import mysql

# revision identifiers, used by Alembic.
revision: str = '7d448d75a6e1'
down_revision: Union[str, None] = '09106b6eef5a'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    connection = op.get_bind()
    
    # 1. 先处理外键约束
    # 获取所有与 payments 表 organization_id 相关的外键约束
    foreign_keys = connection.execute(text("""
        SELECT 
            TABLE_NAME,
            CONSTRAINT_NAME,
            COLUMN_NAME,
            REFERENCED_TABLE_NAME,
            REFERENCED_COLUMN_NAME
        FROM information_schema.KEY_COLUMN_USAGE
        WHERE (REFERENCED_TABLE_NAME = 'payments' AND REFERENCED_COLUMN_NAME = 'organization_id')
        OR (TABLE_NAME = 'payments' AND COLUMN_NAME = 'organization_id')
    """)).fetchall()
    
    # 删除所有相关的外键约束
    for fk in foreign_keys:
        try:
            connection.execute(text(f"ALTER TABLE {fk.TABLE_NAME} DROP FOREIGN KEY {fk.CONSTRAINT_NAME}"))
        except Exception as e:
            print(f"Error dropping foreign key {fk.CONSTRAINT_NAME} on table {fk.TABLE_NAME}: {str(e)}")
    
    # 2. 检查并删除索引（如果存在）
    try:
        # 检查索引是否存在
        result = connection.execute(text("""
            SELECT COUNT(*) as count
            FROM information_schema.statistics
            WHERE table_schema = DATABASE()
            AND table_name = 'payments'
            AND index_name = 'idx_organization_id'
        """)).scalar()
        
        if result > 0:
            op.drop_index('idx_organization_id', table_name='payments')
    except Exception as e:
        print(f"Error handling index idx_organization_id: {str(e)}")
    
    # 3. 处理 policies 表的更改
    # 检查 file_content 列是否存在
    result = connection.execute(text("""
        SELECT COUNT(*) as count
        FROM information_schema.columns
        WHERE table_schema = DATABASE()
        AND table_name = 'policies'
        AND column_name = 'file_content'
    """)).scalar()
    
    if result == 0:
        # 如果列不存在，则添加
        op.add_column('policies', sa.Column('file_content', mysql.LONGTEXT(), nullable=True))
        
        # 从文件系统读取文件内容并更新到数据库
        policies = connection.execute(text("SELECT id, file_path FROM policies")).fetchall()
        
        for policy in policies:
            if policy.file_path and os.path.exists(policy.file_path):
                try:
                    with open(policy.file_path, 'rb') as f:
                        content = f.read().decode('latin-1')
                        connection.execute(
                            text("UPDATE policies SET file_content = :content WHERE id = :id"),
                            {"content": content, "id": policy.id}
                        )
                except Exception as e:
                    print(f"Error reading file {policy.file_path}: {str(e)}")
        
        # 将 file_content 列设置为非空
        op.alter_column('policies', 'file_content',
                        existing_type=mysql.LONGTEXT(),
                        nullable=False)
    
    # 检查 file_path 列是否存在
    result = connection.execute(text("""
        SELECT COUNT(*) as count
        FROM information_schema.columns
        WHERE table_schema = DATABASE()
        AND table_name = 'policies'
        AND column_name = 'file_path'
    """)).scalar()
    
    if result > 0:
        # 如果列存在，则删除
        op.drop_column('policies', 'file_path')
    
    # 4. 处理 transfers 表的外键约束
    transfer_foreign_keys = connection.execute(text("""
        SELECT 
            TABLE_NAME,
            CONSTRAINT_NAME,
            COLUMN_NAME,
            REFERENCED_TABLE_NAME,
            REFERENCED_COLUMN_NAME
        FROM information_schema.KEY_COLUMN_USAGE
        WHERE TABLE_NAME = 'transfers'
        AND COLUMN_NAME IN ('from_user_id', 'organization_id', 'to_bank_account_id')
    """)).fetchall()
    
    # 删除 transfers 表的外键约束
    for fk in transfer_foreign_keys:
        try:
            connection.execute(text(f"ALTER TABLE transfers DROP FOREIGN KEY {fk.CONSTRAINT_NAME}"))
        except Exception as e:
            print(f"Error dropping foreign key {fk.CONSTRAINT_NAME} on table transfers: {str(e)}")
    
    # 检查并删除索引（如果存在）
    for index_name in ['idx_from_user_id', 'idx_organization_id', 'idx_to_bank_account_id']:
        try:
            result = connection.execute(text(f"""
                SELECT COUNT(*) as count
                FROM information_schema.statistics
                WHERE table_schema = DATABASE()
                AND table_name = 'transfers'
                AND index_name = '{index_name}'
            """)).scalar()
            
            if result > 0:
                op.drop_index(index_name, table_name='transfers')
        except Exception as e:
            print(f"Error handling index {index_name}: {str(e)}")
    
    # 5. 重新创建外键约束
    # 重新创建 payments 表的外键约束
    for fk in foreign_keys:
        if fk.REFERENCED_TABLE_NAME == 'payments':
            try:
                connection.execute(text(f"""
                    ALTER TABLE {fk.TABLE_NAME}
                    ADD CONSTRAINT {fk.CONSTRAINT_NAME}
                    FOREIGN KEY ({fk.COLUMN_NAME}) 
                    REFERENCES {fk.REFERENCED_TABLE_NAME}({fk.REFERENCED_COLUMN_NAME})
                """))
            except Exception as e:
                print(f"Error recreating foreign key {fk.CONSTRAINT_NAME}: {str(e)}")
    
    # 重新创建 transfers 表的外键约束
    for fk in transfer_foreign_keys:
        try:
            connection.execute(text(f"""
                ALTER TABLE transfers
                ADD CONSTRAINT {fk.CONSTRAINT_NAME}
                FOREIGN KEY ({fk.COLUMN_NAME}) 
                REFERENCES {fk.REFERENCED_TABLE_NAME}({fk.REFERENCED_COLUMN_NAME})
            """))
        except Exception as e:
            print(f"Error recreating foreign key {fk.CONSTRAINT_NAME}: {str(e)}")
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    connection = op.get_bind()
    
    # 1. 处理外键约束
    # 获取所有与 transfers 表相关的外键约束
    transfer_foreign_keys = connection.execute(text("""
        SELECT 
            TABLE_NAME,
            CONSTRAINT_NAME,
            COLUMN_NAME,
            REFERENCED_TABLE_NAME,
            REFERENCED_COLUMN_NAME
        FROM information_schema.KEY_COLUMN_USAGE
        WHERE TABLE_NAME = 'transfers'
        AND COLUMN_NAME IN ('from_user_id', 'organization_id', 'to_bank_account_id')
    """)).fetchall()
    
    # 删除外键约束
    for fk in transfer_foreign_keys:
        try:
            connection.execute(text(f"ALTER TABLE transfers DROP FOREIGN KEY {fk.CONSTRAINT_NAME}"))
        except Exception as e:
            print(f"Error dropping foreign key {fk.CONSTRAINT_NAME}: {str(e)}")
    
    # 2. 重新创建索引
    op.create_index('idx_to_bank_account_id', 'transfers', ['to_bank_account_id'], unique=False)
    op.create_index('idx_organization_id', 'transfers', ['organization_id'], unique=False)
    op.create_index('idx_from_user_id', 'transfers', ['from_user_id'], unique=False)
    
    # 3. 重新创建外键约束
    for fk in transfer_foreign_keys:
        try:
            connection.execute(text(f"""
                ALTER TABLE transfers
                ADD CONSTRAINT {fk.CONSTRAINT_NAME}
                FOREIGN KEY ({fk.COLUMN_NAME}) 
                REFERENCES {fk.REFERENCED_TABLE_NAME}({fk.REFERENCED_COLUMN_NAME})
            """))
        except Exception as e:
            print(f"Error recreating foreign key {fk.CONSTRAINT_NAME}: {str(e)}")
    
    # 4. 处理 policies 表的回滚
    # 添加回 file_path 列，允许为空
    op.add_column('policies', sa.Column('file_path', mysql.VARCHAR(collation='utf8mb4_unicode_ci', length=255), nullable=True))
    
    # 将文件内容写回文件系统并更新 file_path
    policies = connection.execute(text("SELECT id, file_content FROM policies")).fetchall()
    
    upload_dir = "uploads/policies"
    os.makedirs(upload_dir, exist_ok=True)
    
    for policy in policies:
        if policy.file_content:
            try:
                # 生成新的文件路径
                file_path = os.path.join(upload_dir, f"policy_{policy.id}.pdf")
                # 写入文件
                with open(file_path, 'wb') as f:
                    f.write(policy.file_content.encode('latin-1'))
                # 更新数据库
                connection.execute(
                    text("UPDATE policies SET file_path = :file_path WHERE id = :id"),
                    {"file_path": file_path, "id": policy.id}
                )
            except Exception as e:
                print(f"Error writing file for policy {policy.id}: {str(e)}")
    
    # 将 file_path 列设置为非空
    op.alter_column('policies', 'file_path',
                    existing_type=mysql.VARCHAR(collation='utf8mb4_unicode_ci', length=255),
                    nullable=False)
    
    # 删除 file_content 列
    op.drop_column('policies', 'file_content')
    
    # 5. 处理 payments 表的回滚
    # 获取所有与 payments 表相关的外键约束
    foreign_keys = connection.execute(text("""
        SELECT 
            TABLE_NAME,
            CONSTRAINT_NAME,
            COLUMN_NAME,
            REFERENCED_TABLE_NAME,
            REFERENCED_COLUMN_NAME
        FROM information_schema.KEY_COLUMN_USAGE
        WHERE (REFERENCED_TABLE_NAME = 'payments' AND REFERENCED_COLUMN_NAME = 'organization_id')
        OR (TABLE_NAME = 'payments' AND COLUMN_NAME = 'organization_id')
    """)).fetchall()
    
    # 删除外键约束
    for fk in foreign_keys:
        try:
            connection.execute(text(f"ALTER TABLE {fk.TABLE_NAME} DROP FOREIGN KEY {fk.CONSTRAINT_NAME}"))
        except Exception as e:
            print(f"Error dropping foreign key {fk.CONSTRAINT_NAME}: {str(e)}")
    
    # 重新创建索引
    op.create_index('idx_organization_id', 'payments', ['organization_id'], unique=False)
    
    # 重新创建外键约束
    for fk in foreign_keys:
        if fk.REFERENCED_TABLE_NAME == 'payments':
            try:
                connection.execute(text(f"""
                    ALTER TABLE {fk.TABLE_NAME}
                    ADD CONSTRAINT {fk.CONSTRAINT_NAME}
                    FOREIGN KEY ({fk.COLUMN_NAME}) 
                    REFERENCES {fk.REFERENCED_TABLE_NAME}({fk.REFERENCED_COLUMN_NAME})
                """))
            except Exception as e:
                print(f"Error recreating foreign key {fk.CONSTRAINT_NAME}: {str(e)}")
    # ### end Alembic commands ###
